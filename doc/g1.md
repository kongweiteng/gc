#### Garbage First
##### What(是什么)

```text

Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，G1收集器就被视作JDK 7中HotSpot虚拟机的一项重要进化特征。
到了JDK 8 Update 40的时候，这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Fully-Featured Garbage Collector）。
G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。
现在这个期望目标已经实现过半了，JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，
而CMS则沦落至不推荐使用（Deprecate）的收集器。

在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），
再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，
衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

```

#### Why(为什么)

```text
G1是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间，
收集器能够扮演不同角色的Region采用不同的策略去处理，这样无论新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获得很好的收集效果。

Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1中的新生代和老年代不再是固定的，他们都是一系列区域（不需要连续）的动态集。
G1将Region作为单次回收的最小单元，每次收集到的内存空间都是Region大小的整数倍，这样有计划的避免在整个Java堆中进行区域的垃圾收集。
G1收集器会跟踪各个Region里面的垃圾堆的“价值”大小，然后在后台维护一个优先级列表，优先回收收益最大的哪些Region，这也是“Garbage First”名字的由来。
这样在有限的时间内尽可能高的收集效率。

G1收集器运行过程:


1、初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。
2、并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。
并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。
3、再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。



4、筛选回收（Live Data Counting and Evacuation）：
负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，
然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，
由多条收集器线程并行完成的。

复制阶段停顿分析
复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，
这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。


初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。
因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。
```

##### How(怎么做)
```text

-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200

其中-XX:+UseG1GC为开启G1垃圾收集器，-Xmx32g 设计堆内存的最大内存为32G，
-XX:MaxGCPauseMillis=200设置GC的最大暂停时间为200ms。
如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。

其次，G1将新生代，老年代的物理空间划分取消了。

这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。


```

![a2xFiR.png](https://s1.ax1x.com/2020/08/06/a2xFiR.png)

### [GC介绍](../README.md)